# 如何写一个C++接口类

首先给接口类下了定义：接口类应该是只提供方法声明，而自身不提供方法定义的抽象类。
接口类自身不能实例化，接口类的方法定义/实现只能由接口类的子类来完成。

而对于C++，其接口类一般具有以下特征：

1. 最好不要有成员变量，但可以有静态常量（static const或enum）
如果成员变量，尤其是可变的成员变量，定义在接口中，等于是把实现细节暴露出来了，不符合接口定义的要求，所以一般不在接口中定义可变的成员变量。
而常量可以定义在接口中，因为有时接口需要返回状态，而这些状态可以定义成常量放在接口中。

2. 要有纯虚接口方法
由于不能让接口类自身能够实例化，并且需要子类必须实现接口暴露的方法，*所以接口方法都要声明成纯虚函数*。
声明成纯虚函数意味着接口类自身不需要提供方法的定义，方法的定义需要由接口类的子类提供，并且接口类自身也因此变成了抽象类而不能被实例化。

3. 要有虚析构函数，并提供默认实现
a). 在使用接口类的指针访问接口类的子类的实例时，当对接口类的指针做delete时，如果接口类的析构函数不是虚析构函数的话，将只会调用接口类的析构函数，接口类的子类的析构函数将不会被调用，内存泄露将会产生，所以接口类的析构函数必须定义成虚析构函数。
b). 如果接口类的析构函数不提供默认实现，即如果接口类的析构函数是纯虚析构函数的话，接口类的子类将被迫必须提供析构函数的实现，这样对接口类的子类不友好。
c). 在C++11中也可以用：  virtual ~Testable() = default; 替代 virtual ~Testable() {};

4. 不要声明构造函数
不要显式定义任何的构造函数，但也不要在接口中加入如下代码来禁止生成构造函数
> Testable() = delete;
> Testable(const Testable&) = delete;
因为C++的调用机制要求子类的构造函数调用时一定会先调用父类的构造函数，如果禁止生成构造函数，代码编译时会报错。
如果程序员不显式的提供构造函数，编译器也会隐式的加上构造函数的，虽然这些构造函数对于接口类来说实际没有什么意义。

5. 如何定义标识接口
标识接口是没有任何方法和属性的接口。
> class Testable {
> public:
>     virtual ~Testable() = 0 {}; // #5
> };
只要对纯虚析构函数提供一个默认实现就可以了。这种对纯虚函数提供实现的写法看似很奇怪，但C++的确是支持的。
